\chapter*{Эксперимент №1: Исследования расслоения динамической памяти}
\addcontentsline{toc}{chapter}{Эксперимент №1: Исследования расслоения динамической памяти}

\subsection*{Цель эксперимента}
Определение способа трансляции физического адреса, используемого при обращении к динамической памяти. 

\subsection*{Описание проблемы}
В связи с конструктивной неоднородностью оперативной памяти, обращение к последовательно расположенным данным требует различного времени. В связи с этим, для создания эффективных программ необходимо учитывать расслоение памяти, характеризуемое способом трансляции физического адреса.

\subsection*{Исходные данные}
Размер линейки кэш-памяти верхнего уровня; объем физическойь памяти.


\subsection*{Результаты эксперимента}
На рисунке \ref{img:e1} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Максимальное расстояния между	читаемыми блоками (К) = 128;
	\item Шаг увеличения расстояния между читаемыми 4-х байтовыми ячейками (Б) = 128;
	\item Размер массива (М) = 1.
\end{itemize}

\img{80mm}{e1}{Эксперимет №1, случай 1}
\newpage

На рисунке \ref{img:e1_2} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Максимальное расстояния между	читаемыми блоками (К) = 128;
	\item Шаг увеличения расстояния между читаемыми 4-х байтовыми ячейками (Б) = 32;
	\item Размер массива (М) = 1.
\end{itemize}

\img{80mm}{e1_2}{Эксперимет №1, случай 2}
\newpage

На рисунке \ref{img:e1_3} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Максимальное расстояния между	читаемыми блоками (К) = 128;
	\item Шаг увеличения расстояния между читаемыми 4-х байтовыми ячейками (Б) = 64;
	\item Размер массива (М) = 1.
\end{itemize}

\img{80mm}{e1_3}{Эксперимет №1, случай 3}

Первый пик, который мы видим на рисунке \ref{img:e1} -- адресное расстояние между страницей в одном банке и следующей страницей в том же банке. Это адресное расстояние равно 1024.

При просмотре результатов эксперимента № 1 случая 2, где параметр " Шаг увеличения расстояния между читаемыми 4-х байтовыми ячейками" равен 64, можно заметить, что первый запрос на 64б ждет нормальное количество времени, а вот вторые ждут меньше, третьи опять нормальное количество времени и т.д. То есть можно сказать, что размер одной страницы у нас равен 128б, так как когда мы делаем запрос данных с какой-либо страницы, она загружается полностью, и тогда следующий запрос данных к этой странице уже будет длиться меньше по количеству времени. 

Тогда можно сказать, что если "размер страницы" = "размер динамической памяти" / "количество страниц", то имея результаты приведенные выше, количество страниц = $1024 / 128 = 8$.

\subsection*{Вывод}
Оперативная память неоднородна, и для обращения к последовательно расположенными данным может потребоваться различное количество времени. Поэтому, при создании программ необходимо учитывать расслоение памяти при обработке данных.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Эксперимент №2: Сравнение эффективности ссылочных и векторных структур}
\addcontentsline{toc}{chapter}{Эксперимент №2: Сравнение эффективности ссылочных и векторных структур}

\subsection*{Цель эксперимента}
Оценка влияния зависимости команд по данным на эффективность вычислений. 

\subsection*{Описание проблемы}
Обработка зависимых данных происходит в тех случаях, когда результат работы одной команды используется в качестве адреса операнда другой. При программировании на языках высокого уровня такими операндами являются указатели, активно используемые при обработке ссылочных структур данных: списков, деревьев, графов. Обработка данных структур процессорами с длинными конвейерами команд приводит к заметному увеличению времени работы алгоритмов: адрес загружаемого операнда становится известным только после обработки предыдущей команды. В противоположность этому, обработка векторных структур, таких как массивы, позволяет эффективно использовать аппаратные возможности ЭВМ. 

\subsection*{Результаты эксперимента}
На рисунке \ref{img:e2} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Количество элементов в списке (М) = 1;
	\item Максимальная фрагментации списка (К) = 32;
	\item Шаг увеличения фрагментации (К) = 1.
\end{itemize}

\img{80mm}{e2}{Эксперимет №2}
\newpage

Результат сравнения времени (как вывод программы) представлен на рисунке \ref{img:e2_1}. Как видно на рисунке, список обрабатывается почти в 20 раз медленнее. 

\img{80mm}{e2_1}{Эксперимет №2, результат}

\subsection*{Вывод}
Вывод из полученных результатов можно сделать следующий: использовать структуры данных надо с учетом технологического фактора определенной задачи. Если решаемая задача продполагает возможность использования массива, то надо использовать его, особенно если использование списка не дает существенной разницы (особенно выиграша во времени).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Эксперимент №3: Исследование эффективности программной предвыборки}
\addcontentsline{toc}{chapter}{Эксперимент №3: Исследование эффективности программной предвыборки}

\subsection*{Цель эксперимента}
Выявление способов ускорения вычислений благодаря применению предвыборки данных. 

\subsection*{Исходные данные}
Cтепень ассоциативности и размер TLB данных.

\subsection*{Описание проблемы}
Обработка больших массивов информации сопряжена с открытием большого количества физических страниц памяти. При первом обращении к странице памяти наблюдается увеличенное время доступа к данным. Это связано с необходимостью преобразования логического адреса в физический адрес памяти, а также c открытием страницы динамической памяти и сохранения данных в кэш-памяти.

Преобразование выполняется на основе информации о использованных ранее страницах, содержащейся в TLB буфере процессора. Первое обращение к странице при отсутствии информации в TLB вызывает двойное обращение к оперативной памяти: сначала за информацией из таблицы страниц, а далее за востребованными данными. Предвыборка заключается в заблаговременном проведении всех указанных действий благодаря дополнительному запросу небольшого количества данных из оперативной памяти. 

\subsection*{Результаты эксперимента}
На рисунке \ref{img:e3} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Шаг увеличения расстояния между читаемыми данными
(Б) = 512;
	\item Размер массива (К) = 128.
\end{itemize}

\img{80mm}{e3}{Эксперимет №3}

Результат сравнения времени (как вывод программы) представлен на рисунке \ref{img:e3_1}. Как видно на рисунке, обработка без загрузки таблицы страниц в TLB производилась в 3,7639087 раз дольше.

\img{60mm}{e3_1}{Эксперимет №3, результат}

Красный график - чтение страниц последовательно из оперативной памяти. Зеленый график - чтение страниц, используя дополнительный цикл предвыборки, обеспечивающий своевременную загрузку информации в TLB данных.

Сокращение времени работы алгоритма, который использует предвыборку, происходит в том случае, когда информация о востребованных страницах помещается в TLB. 

Пики на красном графике происходят из-за того, что процессу неободимо преобразовать физический адрес в логический.

\subsection*{Вывод}
Используя предвыборку можно ускорить время работы программы почти в 4 раза (как результат представлен 3.7) за счет заблаговременной загрузки страниц в память.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Эксперимент №4: Исследование способов эффективного чтения оперативной памяти}
\addcontentsline{toc}{chapter}{Эксперимент №4: Исследование способов эффективного чтения оперативной памяти}

\subsection*{Цель эксперимента}
Исследование возможности ускорения вычислений благодаря использованию структур данных, оптимизирующих механизм чтения оперативной памяти.

\subsection*{Исходные данные}
Адресное расстояние между банками памяти, размер буфера чтения.

\subsection*{Описание проблемы}
При обработке информации, находящейся в нескольких страницах и банках оперативной памяти возникают задержки, связанные с необходимостью открытия и закрытия страниц DRAM памяти. При программировании на языках высокого уровня такая ситуация наблюдается при интенсивной обработке нескольких массивов данных или обработке многомерных массивов. При этом процессоры, в которых реализованы механизмы аппаратной предвыборки, часто не могут организовать эффективную загрузку данных. Кроме этого, объемы запрошенных данных оказываются заметно меньше размера пакета, передаваемого из оперативной памяти. Таким образом, эффективная обработка нескольких векторных структур данных без их дополнительной оптимизации не использует в должной степени возможности аппаратных ресурсов. 

\subsection*{Результаты эксперимента}
На рисунке \ref{img:e3} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Размер массива (М) = 2;
	\item Количество потоков данных = 64.
\end{itemize}

\img{80mm}{e4}{Эксперимет №4}

Результат сравнения времени (как вывод программы) представлен на рисунке \ref{img:e4_1}. Как видно на рисунке, неоптимизированная структура обрабатывалась в 1,6596309 раз дольше.

\img{60mm}{e4_1}{Эксперимет №4, результат}

Красный график показывает время или количество тактов работы алгоритма, использующего неоптимизированную структуру.

Зеленый график показывает время (или количество тактов) работы алгоритма с использованием оптимизированной структуры.

Оптимизация заключается в том, что струтура данных, ускоряющая обработку современным процессорам, пытается максимально исключить несвоевременную передачу данных, то есть передавть только лишь востребованную для вычислений инфорацию. Поэтому снижается количество открытий и закрытий страниц DRAM-памяти и обеспечивается параллельная обработка данных, а также выполнение операций загрузки и выгрузки.


\subsection*{Вывод}
Можно сделать вывод, что для ускорения работы алгоритмов, необходимо правильно упорядочить данные.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Эксперимент №5: Исследование конфликтов в кэш-памяти}
\addcontentsline{toc}{chapter}{Эксперимент №5: Исследование конфликтов в кэш-памяти}

\subsection*{Цель эксперимента}
Исследование влияния конфликтов кэш-памяти на эффективность вычислений.


\subsection*{Исходные данные}
Размер банка кэш-памяти данных первого и второго уровня, степень ассоциативности кэш-памяти первого и второго уровня, размер линейки кэшпамяти первого и второго уровня.

\subsection*{Описание проблемы}
Наборно-ассоциативная кэш-память состоит из линеек данных, организованных в несколько независимых банков. Выбор банка для каждой порции кэшируемых данных выполняется по ассоциативному принципу, т.е. из условия улучшения представительности выборки, в то время как целевая линейка в каждом из банков жестко определяется по младшей части физического адреса. Совокупность таких линеек всех банков принято называть набором. Таким образом, попытка читать данные из оперативной памяти с шагом, кратным размеру банка, приводит к их помещению в один и тот же набор.Если же количество запросов превосходит степень ассоциативности кэш-памяти, т.е. количество банков или количество линеек в наборе, то наблюдается постоянное вытеснение данных из кэш-памяти, причем больший ее объем остается незадействованным. 

\subsection*{Результаты эксперимента}
На рисунке \ref{img:e5} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Размер банка кэш-памяти (К) = 128;
	\item Размер линейки кэш-памяти (б) = 128;
	\item Количество читаемых линеек = 32.
\end{itemize}

\img{80mm}{e5}{Эксперимет №5}

Результат сравнения времени (как вывод программы) представлен на рисунке \ref{img:e5_1}. Как видно на рисунке, чтение с конфликтами банков производилось в 9,1083954 раз дольше.

\img{60mm}{e5_1}{Эксперимет №5, результат}
\newpage

Красный график показывает время или количество тактов работы процедуры, читающей данные с конфликтами в кэш-памяти. 

Зеленый график показывает время или количество тактов работы процедуры, не вызывающей конфликтов в кэш-памяти. Ось абсцисс отражает смещение читаемой ячейки от начала блока данных.

Красный график соответствует алгоритму, который построен таким образом, что чтение данных выполняеся с шагом, кратным размеру банка. Именно это и порождает постоянные конфликты в кэш-памяти.

Зеленый график соответсвует алгоритму, который оптимизируется размещение данных в кэш с помощью задания смещения востребованных данных на шаг, достаточный для выбора другого набора. (Шаг соответствует размеру линейки).

\subsection*{Вывод}
Можно сделать вывод, что использование кэш-памяти работа процессора ускоряется почти в 10 раз.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Эксперимент №6: Сравнение алгоритмов сортировки}
\addcontentsline{toc}{chapter}{Эксперимент №6: Сравнение алгоритмов сортировки}

\subsection*{Цель эксперимента}
Исследование способов эффективного использования памяти и выявление наиболее эффективных алгоритмов сортировки, применимых в вычислительных системах. 

\subsection*{Исходные данные}
Количество процессоров вычислительной системы, размер пакета, количество элементов в массиве, разрядность элементов массива.

\subsection*{Описание проблемы}
Существует несколько десятков алгоритмов сортировки. Их можно классифицировать по таким критериям, как: назначение (внутренняя и внешняя сортировки), вычислительная сложность (алгоритмы с вычислительными сложностями $O(n^2), O(n*log(n)), O(n), O(n/log(n))$), емкостная сложность (алгоритмы, требующие и не требующие дополнительного массива), возможность распараллеливания (не распараллеливаемые, ограниченно распараллеливаемые, полностью распараллеливаемые), принцип определения порядка (алгоритмы, использующие парные сравнения и не использующие парные сравнения).  

\subsubsection{Radix Sort}

Логика данной сортировки проста. Допустим, у нас есть массив из 10 чисел.

Сначала идет сортировка их по первому (старшему) разряду. Сортировка в таком случае выполняется с помощью сортировки подсчетом (count sort). Сложность — $O(n)$. 

В итоге получается 10 «корзин» — в которых старший разряд 0, 1, 2 и т.д.

Далее в каждой из корзин запускаем ту же процедуру, но только рассматриваем уже не старший разряд, а следующий за ним, и т.д.

Такие действия выполняется до последнего разряда.

\subsection*{Результаты эксперимента}
На рисунке \ref{img:e6} предаставлен график, полученный в результате эксперимента с исходными параметрами:
\begin{itemize}
	\item Количество 64-х разрядных элементов массивов (М) = 1;
	\item Шаг увеличения размера массива (К) = 32.
\end{itemize}

\img{80mm}{e6}{Эксперимет №6}

Результат сравнения времени (как вывод программы) представлен на рисунке \ref{img:e6_1}. Как видно на рисунке, QuickSort работал в 2,6696797 раз дольше Radix-Counting Sort, и QuickSort работал в 4,0447133 раз дольше Radix-Counting Sort, оптимизированного под 8-процессорную ЭВМ.

\img{60mm}{e6_1}{Эксперимет №5, результат}
\newpage

Фиолетовый график показывает время или количество тактов работы алгоритма QuickSort. 

Красный график показывает время или количество тактов работы неоптимизированного алгоритма Radix-Counting. 

Зеленый график показывает время или количество тактов работы оптимизированного под 8-процессорную вычислительную систему алгоритма Radix-Counting.

\subsection*{Вывод}
Можно сделать вывод о том, что существует сортировка, работающая быстрее чем QuickSort, при этом, даже ее можно еще оптимизировать для более быстрой работы.

